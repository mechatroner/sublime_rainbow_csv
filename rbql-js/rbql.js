// DO NOT EDIT!
// This file was autogenerated from builder.js and template.js using build_engine.js script

const external_js_template_text = `__RBQLMP__user_init_code


class RbqlParsingError extends Error {}
class RbqlRuntimeError extends Error {}


function InternalBadFieldError(idx) {
    this.idx = idx;
    this.name = 'InternalBadFieldError';
}



var unnest_list = null;

var module_was_used_failsafe = false;

// Aggregators:
var aggregation_stage = 0;
var functional_aggregators = [];

var writer = null;

var NU = 0; // NU - Num Updated. Alternative variables: NW (Num Where) - Not Practical. NW (Num Written) - Impossible to implement.
var NR = 0;

var finished_with_error = false;

var external_success_handler = null;
var external_error_handler = null;

var external_input_iterator = null;
var external_writer = null;
var external_join_map_impl = null;

var polymorphic_process = null;
var join_map = null;
var node_debug_mode_flag = false;

const wrong_aggregation_usage_error = 'Usage of RBQL aggregation functions inside JavaScript expressions is not allowed, see the docs';

function finish_processing_error(error_type, error_msg) {
    if (finished_with_error)
        return;
    finished_with_error = true;
    // Stopping input_iterator to trigger exit procedure.
    external_input_iterator.finish();
    external_error_handler(error_type, error_msg);
}


function finish_processing_success() {
    if (finished_with_error)
        return;
    try {
        writer.finish(() => {
            var join_warnings = external_join_map_impl ? external_join_map_impl.get_warnings() : [];
            var warnings = join_warnings.concat(external_writer.get_warnings()).concat(external_input_iterator.get_warnings());
            external_success_handler(warnings);
        });
    } catch (e) {
        if (e instanceof RbqlRuntimeError) {
            finish_processing_error('query execution', e.message);
        } else {
            if (node_debug_mode_flag) {
                console.log('Unexpected exception, dumping stack trace:');
                console.log(e.stack);
            }
            finish_processing_error('unexpected', String(e));
        }
        return;
    }
}


function assert(condition, message) {
    if (!condition) {
        finish_processing_error('unexpected', message);
    }
}


function stable_compare(a, b) {
    for (var i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return a[i] < b[i] ? -1 : 1;
    }
}


function safe_get(record, idx) {
    return idx < record.length ? record[idx] : null;
}


function safe_join_get(record, idx) {
    if (idx < record.length) {
        return record[idx];
    }
    throw new InternalBadFieldError(idx);
}


function safe_set(record, idx, value) {
    if (idx - 1 < record.length) {
        record[idx - 1] = value;
    } else {
        throw new InternalBadFieldError(idx - 1);
    }
}


function RBQLAggregationToken(marker_id, value) {
    this.marker_id = marker_id;
    this.value = value;
    this.toString = function() {
        throw new RbqlParsingError(wrong_aggregation_usage_error);
    }
}


function UnnestMarker() {}


function UNNEST(vals) {
    if (unnest_list !== null) {
        // Technically we can support multiple UNNEST's but the implementation/algorithm is more complex and just doesn't worth it
        throw new RbqlParsingError('Only one UNNEST is allowed per query');
    }
    unnest_list = vals;
    return new UnnestMarker();
}
const unnest = UNNEST;
const Unnest = UNNEST;
const UNFOLD = UNNEST; // "UNFOLD" is deprecated, just for backward compatibility




function parse_number(val) {
    // We can do a more pedantic number test like \`/^ *-{0,1}[0-9]+\\.{0,1}[0-9]* *$/.test(val)\`, but  user will probably use just Number(val) or parseInt/parseFloat
    let result = Number(val);
    if (isNaN(result)) {
        throw new RbqlRuntimeError(\`Unable to convert value "\${val}" to number. MIN, MAX, SUM, AVG, MEDIAN and VARIANCE aggregate functions convert their string arguments to numeric values\`);
    }
    return result;
}


function MinAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, val);
        } else {
            this.stats.set(key, Math.min(cur_aggr, val));
        }
    }

    this.get_final = function(key) {
        return this.stats.get(key);
    }
}



function MaxAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, val);
        } else {
            this.stats.set(key, Math.max(cur_aggr, val));
        }
    }

    this.get_final = function(key) {
        return this.stats.get(key);
    }
}


function SumAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, val);
        } else {
            this.stats.set(key, cur_aggr + val);
        }
    }

    this.get_final = function(key) {
        return this.stats.get(key);
    }
}


function AvgAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, [val, 1]);
        } else {
            var cur_sum = cur_aggr[0];
            var cur_cnt = cur_aggr[1];
            this.stats.set(key, [cur_sum + val, cur_cnt + 1]);
        }
    }

    this.get_final = function(key) {
        var cur_aggr = this.stats.get(key);
        var cur_sum = cur_aggr[0];
        var cur_cnt = cur_aggr[1];
        var avg = cur_sum / cur_cnt;
        return avg;
    }
}


function VarianceAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, [val, val * val, 1]);
        } else {
            var cur_sum = cur_aggr[0];
            var cur_sum_sq = cur_aggr[1];
            var cur_cnt = cur_aggr[2];
            this.stats.set(key, [cur_sum + val, cur_sum_sq + val * val, cur_cnt + 1]);
        }
    }

    this.get_final = function(key) {
        var cur_aggr = this.stats.get(key);
        var cur_sum = cur_aggr[0];
        var cur_sum_sq = cur_aggr[1];
        var cur_cnt = cur_aggr[2];
        var avg_val = cur_sum / cur_cnt;
        var variance = cur_sum_sq / cur_cnt - avg_val * avg_val;
        return variance;
    }
}


function MedianAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        val = parse_number(val);
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, [val]);
        } else {
            cur_aggr.push(val);
        }
    }

    this.get_final = function(key) {
        var cur_aggr = this.stats.get(key);
        cur_aggr.sort(function(a, b) { return a - b; });
        var m = Math.floor(cur_aggr.length / 2);
        if (cur_aggr.length % 2) {
            return cur_aggr[m];
        } else {
            return (cur_aggr[m - 1] + cur_aggr[m]) / 2.0;
        }
    }
}


function CountAggregator() {
    this.stats = new Map();

    this.increment = function(key, val) {
        var cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, 1);
        } else {
            this.stats.set(key, cur_aggr + 1);
        }
    }

    this.get_final = function(key) {
        return this.stats.get(key);
    }
}


function ArrayAggAggregator(post_proc) {
    this.post_proc = post_proc;
    this.stats = new Map();

    this.increment = function(key, val) {
        let cur_aggr = this.stats.get(key);
        if (cur_aggr === undefined) {
            this.stats.set(key, [val]);
        } else {
            cur_aggr.push(val);
        }
    }

    this.get_final = function(key) {
        let cur_aggr = this.stats.get(key);
        return this.post_proc(cur_aggr);
    }
}


function ConstGroupVerifier(output_index) {
    this.output_index = output_index;
    this.const_values = new Map();

    this.increment = function(key, value) {
        var old_value = this.const_values.get(key);
        if (old_value === undefined) {
            this.const_values.set(key, value);
        } else if (old_value != value) {
            throw new RbqlRuntimeError(\`Invalid aggregate expression: non-constant values in output column \${this.output_index + 1}. E.g. "\${old_value}" and "\${value}"\`);
        }
    }

    this.get_final = function(key) {
        return this.const_values.get(key);
    }
}


function init_aggregator(generator_name, val, post_proc=null) {
    aggregation_stage = 1;
    var res = new RBQLAggregationToken(functional_aggregators.length, val);
    if (post_proc === null) {
        functional_aggregators.push(new generator_name());
    } else {
        functional_aggregators.push(new generator_name(post_proc));
    }
    return res;
}


function MIN(val) {
    return aggregation_stage < 2 ? init_aggregator(MinAggregator, val) : val;
}
const min = MIN;
const Min = MIN;


function MAX(val) {
    return aggregation_stage < 2 ? init_aggregator(MaxAggregator, val) : val;
}
const max = MAX;
const Max = MAX;

function COUNT(val) {
    return aggregation_stage < 2 ? init_aggregator(CountAggregator, 1) : 1;
}
const count = COUNT;
const Count = COUNT;

function SUM(val) {
    return aggregation_stage < 2 ? init_aggregator(SumAggregator, val) : val;
}
const sum = SUM;
const Sum = SUM;

function AVG(val) {
    return aggregation_stage < 2 ? init_aggregator(AvgAggregator, val) : val;
}
const avg = AVG;
const Avg = AVG;

function VARIANCE(val) {
    return aggregation_stage < 2 ? init_aggregator(VarianceAggregator, val) : val;
}
const variance = VARIANCE;
const Variance = VARIANCE;

function MEDIAN(val) {
    return aggregation_stage < 2 ? init_aggregator(MedianAggregator, val) : val;
}
const median = MEDIAN;
const Median = MEDIAN;

function ARRAY_AGG(val, post_proc = v => v.join('|')) {
    return aggregation_stage < 2 ? init_aggregator(ArrayAggAggregator, val, post_proc) : val;
}
const array_agg = ARRAY_AGG;
const FOLD = ARRAY_AGG; // "FOLD" is deprecated, just for backward compatibility


function add_to_set(dst_set, value) {
    var len_before = dst_set.size;
    dst_set.add(value);
    return len_before != dst_set.size;
}


function TopWriter(subwriter) {
    this.subwriter = subwriter;
    this.NW = 0;

    this.write = function(record) {
        if (__RBQLMP__top_count !== null && this.NW >= __RBQLMP__top_count)
            return false;
        this.subwriter.write(record);
        this.NW += 1;
        return true;
    }

    this.finish = function(after_finish_callback) {
        this.subwriter.finish(after_finish_callback);
    }
}


function UniqWriter(subwriter) {
    this.subwriter = subwriter;
    this.seen = new Set();

    this.write = function(record) {
        if (!add_to_set(this.seen, JSON.stringify(record)))
            return true;
        if (!this.subwriter.write(record))
            return false;
        return true;
    }

    this.finish = function(after_finish_callback) {
        this.subwriter.finish(after_finish_callback);
    }
}


function UniqCountWriter(subwriter) {
    this.subwriter = subwriter;
    this.records = new Map();

    this.write = function(record) {
        var key = JSON.stringify(record);
        var old_val = this.records.get(key);
        if (old_val) {
            old_val[0] += 1;
        } else {
            this.records.set(key, [1, record]);
        }
        return true;
    }

    this.finish = function(after_finish_callback) {
        for (var [key, value] of this.records) {
            let [count, record] = value;
            record.unshift(count);
            if (!this.subwriter.write(record))
                break;
        }
        this.subwriter.finish(after_finish_callback);
    }
}


function SortedWriter(subwriter) {
    this.subwriter = subwriter;
    this.unsorted_entries = [];

    this.write = function(stable_entry) {
        this.unsorted_entries.push(stable_entry);
        return true;
    }

    this.finish = function(after_finish_callback) {
        var unsorted_entries = this.unsorted_entries;
        unsorted_entries.sort(stable_compare);
        if (__RBQLMP__reverse_flag)
            unsorted_entries.reverse();
        for (var i = 0; i < unsorted_entries.length; i++) {
            var entry = unsorted_entries[i];
            if (!this.subwriter.write(entry[entry.length - 1]))
                break;
        }
        this.subwriter.finish(after_finish_callback);
    }
}


function AggregateWriter(subwriter) {
    this.subwriter = subwriter;
    this.aggregators = [];
    this.aggregation_keys = new Set();

    this.finish = function(after_finish_callback) {
        var all_keys = Array.from(this.aggregation_keys);
        all_keys.sort();
        for (var i = 0; i < all_keys.length; i++) {
            var key = all_keys[i];
            var out_fields = [];
            for (var ag of this.aggregators) {
                out_fields.push(ag.get_final(key));
            }
            if (!this.subwriter.write(out_fields))
                break;
        }
        this.subwriter.finish(after_finish_callback);
    }
}



function FakeJoiner(join_map) {
    this.get_rhs = function(lhs_key) {
        return [null];
    }
}


function InnerJoiner(join_map) {
    this.join_map = join_map;

    this.get_rhs = function(lhs_key) {
        return this.join_map.get_join_records(lhs_key);
    }
}


function LeftJoiner(join_map) {
    this.join_map = join_map;
    this.null_record = [Array(join_map.max_record_len).fill(null)];

    this.get_rhs = function(lhs_key) {
        let result = this.join_map.get_join_records(lhs_key);
        if (result.length == 0) {
            return this.null_record;
        }
        return result;
    }
}


function StrictLeftJoiner(join_map) {
    this.join_map = join_map;

    this.get_rhs = function(lhs_key) {
        let result = this.join_map.get_join_records(lhs_key);
        if (result.length != 1) {
            throw new RbqlRuntimeError('In "STRICT LEFT JOIN" each key in A must have exactly one match in B. Bad A key: "' + lhs_key + '"');
        }
        return result;
    }
}


function select_except(src, except_fields) {
    let result = [];
    for (let i = 0; i < src.length; i++) {
        if (except_fields.indexOf(i) == -1)
            result.push(src[i]);
    }
    return result;
}


function process_update(NF, afields, rhs_records) {
    if (rhs_records.length > 1)
        throw new RbqlRuntimeError('More than one record in UPDATE query matched A-key in join table B');
    var bfields = null;
    if (rhs_records.length == 1)
        bfields = rhs_records[0];
    var up_fields = afields;
    __RBQLMP__init_column_vars_select
    if (rhs_records.length == 1 && (__RBQLMP__where_expression)) {
        NU += 1;
        __RBQLMP__update_statements
    }
    return writer.write(up_fields);
}


function select_simple(sort_key, out_fields) {
    if (__RBQLMP__sort_flag) {
        var sort_entry = sort_key.concat([NR, out_fields]);
        if (!writer.write(sort_entry))
            return false;
    } else {
        if (!writer.write(out_fields))
            return false;
    }
    return true;
}


function select_aggregated(key, transparent_values) {
    if (key !== null) {
        key = JSON.stringify(key);
    }
    if (aggregation_stage === 1) {
        if (!(writer instanceof TopWriter)) {
            throw new RbqlParsingError('Unable to use "ORDER BY" or "DISTINCT" keywords in aggregate query');
        }
        writer = new AggregateWriter(writer);
        let num_aggregators_found = 0;
        for (var i = 0; i < transparent_values.length; i++) {
            var trans_value = transparent_values[i];
            if (trans_value instanceof RBQLAggregationToken) {
                writer.aggregators.push(functional_aggregators[trans_value.marker_id]);
                writer.aggregators[writer.aggregators.length - 1].increment(key, trans_value.value);
                num_aggregators_found += 1;
            } else {
                writer.aggregators.push(new ConstGroupVerifier(writer.aggregators.length));
                writer.aggregators[writer.aggregators.length - 1].increment(key, trans_value);
            }
        }
        if (num_aggregators_found != functional_aggregators.length) {
            throw new RbqlParsingError(wrong_aggregation_usage_error);
        }
        aggregation_stage = 2;
    } else {
        for (var i = 0; i < transparent_values.length; i++) {
            var trans_value = transparent_values[i];
            writer.aggregators[i].increment(key, trans_value);
        }
    }
    writer.aggregation_keys.add(key)
}


function select_unnested(sort_key, folded_fields) {
    let out_fields = folded_fields.slice();
    let unnest_pos = folded_fields.findIndex(val => val instanceof UnnestMarker);
    for (var i = 0; i < unnest_list.length; i++) {
        out_fields[unnest_pos] = unnest_list[i];
        if (!select_simple(sort_key, out_fields.slice()))
            return false;
    }
    return true;
}


function process_select(NF, afields, rhs_records) {
    for (var i = 0; i < rhs_records.length; i++) {
        unnest_list = null;
        var bfields = rhs_records[i];
        var star_fields = afields;
        if (bfields != null)
            star_fields = afields.concat(bfields);
        __RBQLMP__init_column_vars_update
        if (!(__RBQLMP__where_expression))
            continue;
        // TODO wrap all user expression in try/catch block to improve error reporting
        var out_fields = __RBQLMP__select_expression;
        if (aggregation_stage > 0) {
            var key = __RBQLMP__aggregation_key_expression;
            select_aggregated(key, out_fields);
        } else {
            var sort_key = [__RBQLMP__sort_key_expression];
            if (unnest_list !== null) {
                if (!select_unnested(sort_key, out_fields))
                    return false;
            } else {
                if (!select_simple(sort_key, out_fields))
                    return false;
            }
        }
    }
    return true;
}


function process_record(record) {
    NR += 1;
    if (finished_with_error)
        return;
    try {
        do_process_record(record);
    } catch (e) {
        if (e instanceof InternalBadFieldError) {
            finish_processing_error('query execution', 'No "a' + (e.idx + 1) + '" column at record: ' + NR);
        } else if (e instanceof RbqlRuntimeError) {
            finish_processing_error('query execution', e.message);
        } else if (e instanceof RbqlParsingError) {
            finish_processing_error('query parsing', e.message);
        } else {
            if (node_debug_mode_flag) {
                console.log('Unexpected exception, dumping stack trace:');
                console.log(e.stack);
            }
            finish_processing_error('query execution', \`At record: \${NR}, Details: \${String(e)}\`);
        }
    }
}


function do_process_record(afields) {
    let rhs_records = join_map.get_rhs(__RBQLMP__lhs_join_var);
    let NF = afields.length;
    if (!polymorphic_process(NF, afields, rhs_records)) {
        external_input_iterator.finish();
        return;
    }
}


function do_rb_transform(input_iterator, output_writer) {
    polymorphic_process = __RBQLMP__is_select_query ? process_select : process_update;
    var sql_join_type = {'VOID': FakeJoiner, 'JOIN': InnerJoiner, 'INNER JOIN': InnerJoiner, 'LEFT JOIN': LeftJoiner, 'STRICT LEFT JOIN': StrictLeftJoiner}['__RBQLMP__join_operation'];

    join_map = new sql_join_type(external_join_map_impl);

    writer = new TopWriter(output_writer);

    if ('__RBQLMP__writer_type' == 'uniq') {
        writer = new UniqWriter(writer);
    } else if ('__RBQLMP__writer_type' == 'uniq_count') {
        writer = new UniqCountWriter(writer);
    }

    if (__RBQLMP__sort_flag)
        writer = new SortedWriter(writer);

    input_iterator.set_record_callback(process_record);
    input_iterator.start();
}


function rb_transform(input_iterator, join_map_impl, output_writer, external_success_cb, external_error_cb, node_debug_mode=false) {
    node_debug_mode_flag = node_debug_mode;
    external_success_handler = external_success_cb;
    external_error_handler = external_error_cb;
    external_input_iterator = input_iterator;
    external_writer = output_writer;
    external_join_map_impl = join_map_impl;

    input_iterator.set_finish_callback(finish_processing_success);

    if (module_was_used_failsafe) {
        finish_processing_error('unexpected', 'Module can only be used once');
        return;
    }
    module_was_used_failsafe = true;

    try {
        if (external_join_map_impl !== null) {
            external_join_map_impl.build(function() { do_rb_transform(input_iterator, output_writer); }, finish_processing_error);
        } else {
            do_rb_transform(input_iterator, output_writer);
        }

    } catch (e) {
        if (e instanceof RbqlRuntimeError) {
            finish_processing_error('query execution', e.message);
        } else if (e instanceof RbqlParsingError) {
            finish_processing_error('query parsing', e.message);
        } else {
            if (node_debug_mode_flag) {
                console.log('Unexpected exception, dumping stack trace:');
                console.log(e.stack);
            }
            finish_processing_error('unexpected', String(e));
        }
    }
}


module.exports.rb_transform = rb_transform;
`;
// ^ The expression above will cause builder.js and tempalte.js to be combined to autogenerate rbql.js: builder.js + template.js -> ../rbql.js
// Expression is written as a function to pacify the linter.
// Unit tests will ensure that rbql.js is indeed a concatenation of builder.js and template.js


// This module works with records only. It is CSV-agnostic.
// Do not add CSV-related logic or variables/functions/objects like "delim", "separator" etc


// TODO get rid of functions with "_js" suffix


// TODO replace prototypes with classes: this improves readability


const version = '0.9.0';

const GROUP_BY = 'GROUP BY';
const UPDATE = 'UPDATE';
const SELECT = 'SELECT';
const JOIN = 'JOIN';
const INNER_JOIN = 'INNER JOIN';
const LEFT_JOIN = 'LEFT JOIN';
const STRICT_LEFT_JOIN = 'STRICT LEFT JOIN';
const ORDER_BY = 'ORDER BY';
const WHERE = 'WHERE';
const LIMIT = 'LIMIT';
const EXCEPT = 'EXCEPT';


class RbqlParsingError extends Error {}
class RbqlIOHandlingError extends Error {}
class AssertionError extends Error {}

var debug_mode = false;

function assert(condition, message=null) {
    if (!condition) {
        if (!message) {
            message = 'Assertion error';
        }
        throw new AssertionError(message);
    }
}


function get_all_matches(regexp, text) {
    var result = [];
    let match_obj = null;
    while((match_obj = regexp.exec(text)) !== null) {
        result.push(match_obj);
    }
    return result;
}


function replace_all(src, search, replacement) {
    return src.split(search).join(replacement);
}


function str_strip(src) {
    return src.replace(/^ +| +$/g, '');
}


function rbql_meta_format(template_src, meta_params) {
    for (var key in meta_params) {
        if (!meta_params.hasOwnProperty(key))
            continue;
        var value = meta_params[key];
        var template_src_upd = replace_all(template_src, key, value);
        assert(template_src_upd != template_src);
        template_src = template_src_upd;
    }
    return template_src;
}


function strip_comments(cline) {
    cline = cline.trim();
    if (cline.startsWith('//'))
        return '';
    return cline;
}


function parse_join_expression(src) {
    var rgx = /^ *([^ ]+) +on +([ab][0-9]+) *== *([ab][0-9]+) *$/i;
    var match = rgx.exec(src);
    if (match === null) {
        throw new RbqlParsingError('Invalid join syntax. Must be: "<JOIN> /path/to/B/table on a<i> == b<j>"');
    }
    var table_id = match[1];
    var avar = match[2];
    var bvar = match[3];
    if (avar.charAt(0) == 'b') {
        [avar, bvar] = [bvar, avar];
    }
    if (avar.charAt(0) != 'a' || bvar.charAt(0) != 'b') {
        throw new RbqlParsingError('Invalid join syntax. Must be: "<JOIN> /path/to/B/table on a<i> == b<j>"');
    }
    avar = parseInt(avar.substr(1)) - 1;
    var lhs_join_var = `safe_join_get(afields, ${avar})`;
    let rhs_key_index = parseInt(bvar.substr(1)) - 1;
    return [table_id, lhs_join_var, rhs_key_index];
}


function generate_init_statements(column_vars, indent) {
    var init_statements = [];
    for (var i = 0; i < column_vars.length; i++) {
        var var_name = column_vars[i];
        var var_group = var_name.charAt(0);
        var zero_based_idx = parseInt(var_name.substr(1)) - 1;
        if (var_group == 'a') {
            init_statements.push(`var ${var_name} = safe_get(afields, ${zero_based_idx});`);
        } else {
            init_statements.push(`var ${var_name} = bfields === null ? null : safe_get(bfields, ${zero_based_idx});`);
        }
    }
    for (var i = 1; i < init_statements.length; i++) {
        init_statements[i] = indent + init_statements[i];
    }
    return init_statements.join('\n');
}


function replace_star_count(aggregate_expression) {
    var rgx = /(^|,) *COUNT\( *\* *\) *(?:$|(?=,))/ig;
    var result = aggregate_expression.replace(rgx, '$1 COUNT(1)');
    return str_strip(result);
}


function replace_star_vars(rbql_expression) {
    var middle_star_rgx = /(?:^|,) *\* *(?=, *\* *($|,))/g;
    rbql_expression = rbql_expression.replace(middle_star_rgx, ']).concat(star_fields).concat([');
    var last_star_rgx = /(?:^|,) *\* *(?:$|,)/g;
    rbql_expression = rbql_expression.replace(last_star_rgx, ']).concat(star_fields).concat([');
    return rbql_expression;
}


function translate_update_expression(update_expression, indent) {
    var rgx = /(?:^|,) *a([1-9][0-9]*) *=(?=[^=])/g;
    var translated = update_expression.replace(rgx, '\nsafe_set(up_fields, $1,');
    var update_statements = translated.split('\n');
    update_statements = update_statements.map(str_strip);
    if (update_statements.length < 2 || update_statements[0] != '') {
        throw new RbqlParsingError('Unable to parse "UPDATE" expression');
    }
    update_statements = update_statements.slice(1);
    for (var i = 0; i < update_statements.length; i++) {
        update_statements[i] = update_statements[i] + ')';
    }
    for (var i = 1; i < update_statements.length; i++) {
        update_statements[i] = indent + update_statements[i];
    }
    var translated = update_statements.join('\n');
    return translated;
}


function translate_select_expression_js(select_expression) {
    var translated = replace_star_count(select_expression);
    translated = replace_star_vars(translated);
    translated = str_strip(translated);
    if (!translated.length) {
        throw new RbqlParsingError('"SELECT" expression is empty');
    }
    return `[].concat([${translated}])`;
}


function separate_string_literals_js(rbql_expression) {
    // The regex consists of 3 almost identicall parts, the only difference is quote type
    var rgx = /('(\\(\\\\)*'|[^'])*')|("(\\(\\\\)*"|[^"])*")|(`(\\(\\\\)*`|[^`])*`)/g;
    var match_obj = null;
    var format_parts = [];
    var string_literals = [];
    var idx_before = 0;
    while((match_obj = rgx.exec(rbql_expression)) !== null) {
        var literal_id = string_literals.length;
        var string_literal = match_obj[0];
        string_literals.push(string_literal);
        var start_index = match_obj.index;
        format_parts.push(rbql_expression.substring(idx_before, start_index));
        format_parts.push(`###RBQL_STRING_LITERAL###${literal_id}`);
        idx_before = rgx.lastIndex;
    }
    format_parts.push(rbql_expression.substring(idx_before));
    var format_expression = format_parts.join('');
    format_expression = format_expression.replace(/\t/g, ' ');
    return [format_expression, string_literals];
}


function combine_string_literals(backend_expression, string_literals) {
    for (var i = string_literals.length - 1; i >= 0; i--) {
        backend_expression = replace_all(backend_expression, `###RBQL_STRING_LITERAL###${i}`, string_literals[i]);
    }
    return backend_expression;
}


function locate_statements(rbql_expression) {
    let statement_groups = [];
    statement_groups.push([STRICT_LEFT_JOIN, LEFT_JOIN, INNER_JOIN, JOIN]);
    statement_groups.push([SELECT]);
    statement_groups.push([ORDER_BY]);
    statement_groups.push([WHERE]);
    statement_groups.push([UPDATE]);
    statement_groups.push([GROUP_BY]);
    statement_groups.push([LIMIT]);
    statement_groups.push([EXCEPT]);
    var result = [];
    for (var ig = 0; ig < statement_groups.length; ig++) {
        for (var is = 0; is < statement_groups[ig].length; is++) {
            var statement = statement_groups[ig][is];
            var rgxp = new RegExp('(?:^| )' + replace_all(statement, ' ', ' *') + '(?= )', 'ig');
            var matches = get_all_matches(rgxp, rbql_expression);
            if (!matches.length)
                continue;
            if (matches.length > 1)
                throw new RbqlParsingError(`More than one ${statement} statements found`);
            assert(matches.length == 1);
            var match = matches[0];
            var match_str = match[0];
            result.push([match.index, match.index + match_str.length, statement]);
            break; // Break to avoid matching a sub-statement from the same group e.g. "INNER JOIN" -> "JOIN"
        }
    }
    result.sort(function(a, b) { return a[0] - b[0]; });
    return result;
}


function separate_actions(rbql_expression) {
    rbql_expression = str_strip(rbql_expression);
    var ordered_statements = locate_statements(rbql_expression);
    var result = {};
    for (var i = 0; i < ordered_statements.length; i++) {
        var statement_start = ordered_statements[i][0];
        var span_start = ordered_statements[i][1];
        var statement = ordered_statements[i][2];
        var span_end = i + 1 < ordered_statements.length ? ordered_statements[i + 1][0] : rbql_expression.length;
        assert(statement_start < span_start);
        assert(span_start <= span_end);
        var span = rbql_expression.substring(span_start, span_end);
        var statement_params = {};
        if ([STRICT_LEFT_JOIN, LEFT_JOIN, INNER_JOIN, JOIN].indexOf(statement) != -1) {
            statement_params['join_subtype'] = statement;
            statement = JOIN;
        }

        if (statement == UPDATE) {
            if (statement_start != 0)
                throw new RbqlParsingError('UPDATE keyword must be at the beginning of the query');
            span = span.replace(/^ *SET/i, '');
        }

        if (statement == ORDER_BY) {
            span = span.replace(/ ASC *$/i, '');
            var new_span = span.replace(/ DESC *$/i, '');
            if (new_span != span) {
                span = new_span;
                statement_params['reverse'] = true;
            } else {
                statement_params['reverse'] = false;
            }
        }

        if (statement == SELECT) {
            if (statement_start != 0)
                throw new RbqlParsingError('SELECT keyword must be at the beginning of the query');
            var match = /^ *TOP *([0-9]+) /i.exec(span);
            if (match !== null) {
                statement_params['top'] = parseInt(match[1]);
                span = span.substr(match.index + match[0].length);
            }
            match = /^ *DISTINCT *(COUNT)? /i.exec(span);
            if (match !== null) {
                statement_params['distinct'] = true;
                if (match[1]) {
                    statement_params['distinct_count'] = true;
                }
                span = span.substr(match.index + match[0].length);
            }
        }
        statement_params['text'] = str_strip(span);
        result[statement] = statement_params;
    }
    if (!result.hasOwnProperty(SELECT) && !result.hasOwnProperty(UPDATE)) {
        throw new RbqlParsingError('Query must contain either SELECT or UPDATE statement');
    }
    assert(result.hasOwnProperty(SELECT) != result.hasOwnProperty(UPDATE));
    return result;
}


function find_top(rb_actions) {
    if (rb_actions.hasOwnProperty(LIMIT)) {
        var result = parseInt(rb_actions[LIMIT]['text']);
        if (isNaN(result)) {
            throw new RbqlParsingError('LIMIT keyword must be followed by an integer');
        }
        return result;
    }
    var select_action = rb_actions[SELECT];
    if (select_action && select_action.hasOwnProperty('top')) {
        return select_action['top'];
    }
    return null;
}


function indent_user_init_code(user_init_code) {
    let source_lines = user_init_code.split(/(?:\r\n)|\r|\n/);
    source_lines = source_lines.map(line => '    ' + line);
    return source_lines.join('\n');
}


function extract_column_vars(rbql_expression) {
    var rgx = /(?:^|[^_a-zA-Z0-9])([ab][1-9][0-9]*)(?:$|(?=[^_a-zA-Z0-9]))/g;
    var result = [];
    var seen = {};
    var matches = get_all_matches(rgx, rbql_expression);
    for (var i = 0; i < matches.length; i++) {
        var var_name = matches[i][1];
        if (!seen.hasOwnProperty(var_name)) {
            result.push(var_name);
            seen[var_name] = 1;
        }
    }
    return result;
}


function translate_except_expression(except_expression) {
    let skip_vars = except_expression.split(',');
    let skip_indices = [];
    let rgx = /^a[1-9][0-9]*$/;
    for (let i = 0; i < skip_vars.length; i++) {
        let skip_var = str_strip(skip_vars[i]);
        let match = rgx.exec(skip_var);
        if (match === null) {
            throw new RbqlParsingError('Invalid EXCEPT syntax');
        }
        skip_indices.push(parseInt(skip_var.substring(1)) - 1);
    }
    skip_indices = skip_indices.sort((a, b) => a - b);
    let indices_str = skip_indices.join(',');
    return `select_except(afields, [${indices_str}])`;
}


function HashJoinMap(record_iterator, key_index) {
    this.max_record_len = 0;
    this.hash_map = new Map();
    this.record_iterator = record_iterator;
    this.key_index = key_index;
    this.error_msg = null;
    this.external_error_handler = null;
    this.external_success_handler = null;
    this.nr = 0;

    this.finish_build = function() {
        if (this.error_msg === null) {
            this.external_success_handler();
        } else {
            this.external_error_handler('IO handling', this.error_msg);
        }
    };

    this.add_record = function(record) {
        this.nr += 1;
        let num_fields = record.length;
        this.max_record_len = Math.max(this.max_record_len, num_fields);
        if (this.key_index >= num_fields) {
            this.error_msg = `No "b${this.key_index + 1}" field at record: ${this.nr} in "B" table`;
            this.record_iterator.finish();
        }
        let key = record[this.key_index];
        let key_records = this.hash_map.get(key);
        if (key_records === undefined) {
            this.hash_map.set(key, [record]);
        } else {
            key_records.push(record);
        }
    };

    this.build = function(success_callback, error_callback) {
        this.external_success_handler = success_callback;
        this.external_error_handler = error_callback;
        this.record_iterator.set_record_callback((record) => { this.add_record(record); });
        this.record_iterator.set_finish_callback(() => { this.finish_build(); });
        this.record_iterator.start();
    };

    this.get_join_records = function(key) {
        let result = this.hash_map.get(key);
        if (result === undefined)
            return [];
        return result;
    };

    this.get_warnings = function() {
        return this.record_iterator.get_warnings();
    };
}


function parse_to_js(query, js_template_text, join_tables_registry, user_init_code) {
    let rbql_lines = query.split('\n');
    rbql_lines = rbql_lines.map(strip_comments);
    rbql_lines = rbql_lines.filter(line => line.length);
    var full_rbql_expression = rbql_lines.join(' ');
    var column_vars = extract_column_vars(full_rbql_expression);
    var [format_expression, string_literals] = separate_string_literals_js(full_rbql_expression);
    var rb_actions = separate_actions(format_expression);

    var js_meta_params = {};
    js_meta_params['__RBQLMP__user_init_code'] = user_init_code;

    if (rb_actions.hasOwnProperty(ORDER_BY) && rb_actions.hasOwnProperty(UPDATE))
        throw new RbqlParsingError('"ORDER BY" is not allowed in "UPDATE" queries');

    if (rb_actions.hasOwnProperty(GROUP_BY)) {
        if (rb_actions.hasOwnProperty(ORDER_BY) || rb_actions.hasOwnProperty(UPDATE))
            throw new RbqlParsingError('"ORDER BY" and "UPDATE" are not allowed in aggregate queries');
        var aggregation_key_expression = rb_actions[GROUP_BY]['text'];
        js_meta_params['__RBQLMP__aggregation_key_expression'] = '[' + combine_string_literals(aggregation_key_expression, string_literals) + ']';
    } else {
        js_meta_params['__RBQLMP__aggregation_key_expression'] = 'null';
    }

    let join_map = null;
    if (rb_actions.hasOwnProperty(JOIN)) {
        var [rhs_table_id, lhs_join_var, rhs_key_index] = parse_join_expression(rb_actions[JOIN]['text']);
        js_meta_params['__RBQLMP__join_operation'] = rb_actions[JOIN]['join_subtype'];
        js_meta_params['__RBQLMP__lhs_join_var'] = lhs_join_var;
        if (join_tables_registry === null)
            throw new RbqlParsingError('JOIN operations were disabled');
        let join_record_iterator = join_tables_registry.get_iterator_by_table_id(rhs_table_id);
        if (!join_record_iterator)
            throw new RbqlParsingError(`Unable to find join table: "${rhs_table_id}"`);
        join_map = new HashJoinMap(join_record_iterator, rhs_key_index);
    } else {
        js_meta_params['__RBQLMP__join_operation'] = 'VOID';
        js_meta_params['__RBQLMP__lhs_join_var'] = 'null';
    }

    if (rb_actions.hasOwnProperty(WHERE)) {
        var where_expression = rb_actions[WHERE]['text'];
        if (/[^!=]=[^=]/.exec(where_expression)) {
            throw new RbqlParsingError('Assignments "=" are not allowed in "WHERE" expressions. For equality test use "==" or "==="');
        }
        js_meta_params['__RBQLMP__where_expression'] = combine_string_literals(where_expression, string_literals);
    } else {
        js_meta_params['__RBQLMP__where_expression'] = 'true';
    }


    if (rb_actions.hasOwnProperty(UPDATE)) {
        var update_expression = translate_update_expression(rb_actions[UPDATE]['text'], ' '.repeat(8));
        js_meta_params['__RBQLMP__writer_type'] = 'simple';
        js_meta_params['__RBQLMP__select_expression'] = 'null';
        js_meta_params['__RBQLMP__update_statements'] = combine_string_literals(update_expression, string_literals);
        js_meta_params['__RBQLMP__is_select_query'] = 'false';
        js_meta_params['__RBQLMP__top_count'] = 'null';
    }

    js_meta_params['__RBQLMP__init_column_vars_update'] = generate_init_statements(column_vars, ' '.repeat(4));
    js_meta_params['__RBQLMP__init_column_vars_select'] = generate_init_statements(column_vars, ' '.repeat(8));

    if (rb_actions.hasOwnProperty(SELECT)) {
        var top_count = find_top(rb_actions);
        js_meta_params['__RBQLMP__top_count'] = top_count === null ? 'null' : String(top_count);
        if (rb_actions[SELECT].hasOwnProperty('distinct_count')) {
            js_meta_params['__RBQLMP__writer_type'] = 'uniq_count';
        } else if (rb_actions[SELECT].hasOwnProperty('distinct')) {
            js_meta_params['__RBQLMP__writer_type'] = 'uniq';
        } else {
            js_meta_params['__RBQLMP__writer_type'] = 'simple';
        }
        if (rb_actions.hasOwnProperty(EXCEPT)) {
            js_meta_params['__RBQLMP__select_expression'] = translate_except_expression(rb_actions[EXCEPT]['text']);
        } else {
            let select_expression = translate_select_expression_js(rb_actions[SELECT]['text']);
            js_meta_params['__RBQLMP__select_expression'] = combine_string_literals(select_expression, string_literals);
        }
        js_meta_params['__RBQLMP__update_statements'] = '';
        js_meta_params['__RBQLMP__is_select_query'] = 'true';
    }

    if (rb_actions.hasOwnProperty(ORDER_BY)) {
        var order_expression = rb_actions[ORDER_BY]['text'];
        js_meta_params['__RBQLMP__sort_key_expression'] = combine_string_literals(order_expression, string_literals);
        js_meta_params['__RBQLMP__reverse_flag'] = rb_actions[ORDER_BY]['reverse'] ? 'true' : 'false';
        js_meta_params['__RBQLMP__sort_flag'] = 'true';
    } else {
        js_meta_params['__RBQLMP__sort_key_expression'] = 'null';
        js_meta_params['__RBQLMP__reverse_flag'] = 'false';
        js_meta_params['__RBQLMP__sort_flag'] = 'false';
    }
    var js_code = rbql_meta_format(js_template_text, js_meta_params);
    return [js_code, join_map];
}


function load_module_from_file(js_code) {
    let os = require('os');
    let path = require('path');
    let fs = require('fs');
    var tmp_dir = os.tmpdir();
    var script_filename = 'rbconvert_' + String(Math.random()).replace('.', '_') + '.js';
    let tmp_worker_module_path = path.join(tmp_dir, script_filename);
    fs.writeFileSync(tmp_worker_module_path, js_code);
    let worker_module = require(tmp_worker_module_path);
    return worker_module;
}


function generic_run(user_query, input_iterator, output_writer, success_handler, error_handler, join_tables_registry=null, user_init_code='') {
    try {
        user_init_code = indent_user_init_code(user_init_code);
        let [js_code, join_map] = parse_to_js(user_query, external_js_template_text, join_tables_registry, user_init_code);
        let rbql_worker = null;
        if (debug_mode) {
            rbql_worker = load_module_from_file(js_code);
        } else {
            let module = {'exports': {}};
            eval('(function(){' + js_code + '})()');
            rbql_worker = module.exports;
        }
        rbql_worker.rb_transform(input_iterator, join_map, output_writer, success_handler, error_handler, debug_mode);
    } catch (e) {
        if (e instanceof RbqlParsingError) {
            error_handler('query parsing', e.message);
        } else {
            if (debug_mode) {
                console.log('Unexpected exception, dumping stack trace:');
                console.log(e.stack);
            }
            error_handler('unexpected', 'Unexpected exception: ' + e);
        }
    }
}


function make_inconsistent_num_fields_warning(table_name, inconsistent_records_info) {
    let keys = Object.keys(inconsistent_records_info);
    let entries = [];
    for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let record_id = inconsistent_records_info[key];
        entries.push([record_id, key]);
    }
    entries.sort(function(a, b) { return a[0] - b[0]; });
    assert(entries.length > 1);
    let [record_1, num_fields_1] = entries[0];
    let [record_2, num_fields_2] = entries[1];
    let warn_msg = `Number of fields in "${table_name}" table is not consistent: `;
    warn_msg += `e.g. record ${record_1} -> ${num_fields_1} fields, record ${record_2} -> ${num_fields_2} fields`;
    return warn_msg;
}


function TableIterator(input_table) {
    this.input_table = input_table;
    this.NR = 0;
    this.fields_info = new Object();
    this.external_record_callback = null;
    this.external_finish_callback = null;
    this.finished = false;


    this.set_record_callback = function(external_record_callback) {
        this.external_record_callback = external_record_callback;
    };


    this.set_finish_callback = function(external_finish_callback) {
        this.external_finish_callback = external_finish_callback;
    };


    this.start = function() {
        while (!this.finished) {
            let record = this.get_record();
            if (record === null) {
                this.finish();
            } else {
                this.external_record_callback(record);
            }
        }
    };


    this.finish = function() {
        if (!this.finished) {
            this.finished = true;
            this.external_finish_callback();
        }
    };


    this.get_record = function() {
        if (this.NR >= this.input_table.length)
            return null;
        let record = this.input_table[this.NR];
        this.NR += 1;
        let num_fields = record.length;
        if (!this.fields_info.hasOwnProperty(num_fields))
            this.fields_info[num_fields] = this.NR;
        return record;
    };

    this.get_warnings = function() {
        if (Object.keys(this.fields_info).length > 1)
            return [make_inconsistent_num_fields_warning('input', this.fields_info)];
        return [];
    };
}


function TableWriter(external_table) {
    this.table = external_table;

    this.write = function(fields) {
        this.table.push(fields);
    };

    this.finish = function(after_finish_callback) {
        after_finish_callback();
    };

    this.get_warnings = function() {
        return [];
    };
}


function SingleTableRegistry(table, table_id='B') {
    this.table = table;
    this.table_id = table_id;

    this.get_iterator_by_table_id = function(table_id) {
        if (table_id !== this.table_id) {
            throw new RbqlIOHandlingError(`Unable to find join table: "${table_id}"`);
        }
        return new TableIterator(this.table);
    };
}


function table_run(user_query, input_table, output_table, success_handler, error_handler, join_table=null, user_init_code='') {
    let input_iterator = new TableIterator(input_table);
    let output_writer = new TableWriter(output_table);
    let join_tables_registry = join_table === null ? null : new SingleTableRegistry(join_table);
    generic_run(user_query, input_iterator, output_writer, success_handler, error_handler, join_tables_registry, user_init_code);
}


function set_debug_mode() {
    debug_mode = true;
}


module.exports.version = version;
module.exports.generic_run = generic_run;
module.exports.table_run = table_run;

module.exports.TableIterator = TableIterator;
module.exports.TableWriter = TableWriter;
module.exports.SingleTableRegistry = SingleTableRegistry;

module.exports.strip_comments = strip_comments;
module.exports.separate_actions = separate_actions;
module.exports.separate_string_literals_js = separate_string_literals_js;
module.exports.combine_string_literals = combine_string_literals;
module.exports.translate_except_expression = translate_except_expression;
module.exports.parse_join_expression = parse_join_expression;
module.exports.translate_update_expression = translate_update_expression;
module.exports.translate_select_expression_js = translate_select_expression_js;

module.exports.set_debug_mode = set_debug_mode;


// DO NOT EDIT!
// This file was autogenerated from builder.js and template.js using build_engine.js script

